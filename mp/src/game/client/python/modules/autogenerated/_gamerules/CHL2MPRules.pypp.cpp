// This file has been generated by Py++.

#include "cbase.h"
// This file has been generated by Py++.

#include "cbase.h"
#include "gamerules.h"
#include "multiplay_gamerules.h"
#include "singleplay_gamerules.h"
#include "teamplay_gamerules.h"
#include "srcpy_gamerules.h"
#include "ammodef.h"
#include "takedamageinfo.h"
#include "hl2mp/hl2mp_gamerules.h"
#include "tier0/valve_minmax_off.h"
#include "srcpy.h"
#include "tier0/valve_minmax_on.h"
#include "tier0/memdbgon.h"
#include "CHL2MPRules.pypp.hpp"

namespace bp = boost::python;

struct C_HL2MPRules_wrapper : C_HL2MPRules, bp::wrapper< C_HL2MPRules > {

    C_HL2MPRules_wrapper( )
    : C_HL2MPRules( )
      , bp::wrapper< C_HL2MPRules >(){
        // null constructor
    
    }

    virtual bool ClientCommand( ::C_BaseEntity * pEdict, ::CCommand const & args ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, ClientCommand )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, ClientCommand )
        bp::override func_ClientCommand = this->get_override( "ClientCommand" );
        if( func_ClientCommand.ptr() != Py_None )
            try {
                return func_ClientCommand( pEdict ? pEdict->GetPyHandle() : boost::python::object(), boost::ref(args) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::ClientCommand( pEdict, args );
            }
        else
            return this->C_HL2MPRules::ClientCommand( pEdict, args );
    }
    
    bool default_ClientCommand( ::C_BaseEntity * pEdict, ::CCommand const & args ) {
        return C_HL2MPRules::ClientCommand( pEdict, args );
    }

    virtual void ClientDisconnected( ::edict_t * pClient ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, ClientDisconnected )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, ClientDisconnected )
        bp::override func_ClientDisconnected = this->get_override( "ClientDisconnected" );
        if( func_ClientDisconnected.ptr() != Py_None )
            try {
                func_ClientDisconnected( boost::python::ptr(pClient) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::ClientDisconnected( pClient );
            }
        else
            this->C_HL2MPRules::ClientDisconnected( pClient );
    }
    
    void default_ClientDisconnected( ::edict_t * pClient ) {
        C_HL2MPRules::ClientDisconnected( pClient );
    }

    virtual void ClientSettingsChanged( ::C_BasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, ClientSettingsChanged )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, ClientSettingsChanged )
        bp::override func_ClientSettingsChanged = this->get_override( "ClientSettingsChanged" );
        if( func_ClientSettingsChanged.ptr() != Py_None )
            try {
                func_ClientSettingsChanged( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::ClientSettingsChanged( pPlayer );
            }
        else
            this->C_HL2MPRules::ClientSettingsChanged( pPlayer );
    }
    
    void default_ClientSettingsChanged( ::C_BasePlayer * pPlayer ) {
        C_HL2MPRules::ClientSettingsChanged( pPlayer );
    }

    virtual void CreateStandardEntities(  ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, CreateStandardEntities )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, CreateStandardEntities )
        bp::override func_CreateStandardEntities = this->get_override( "CreateStandardEntities" );
        if( func_CreateStandardEntities.ptr() != Py_None )
            try {
                func_CreateStandardEntities(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::CreateStandardEntities(  );
            }
        else
            this->C_HL2MPRules::CreateStandardEntities(  );
    }
    
    void default_CreateStandardEntities(  ) {
        C_HL2MPRules::CreateStandardEntities( );
    }

    virtual void DeathNotice( ::C_BasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, DeathNotice )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, DeathNotice )
        bp::override func_DeathNotice = this->get_override( "DeathNotice" );
        if( func_DeathNotice.ptr() != Py_None )
            try {
                func_DeathNotice( pVictim ? pVictim->GetPyHandle() : boost::python::object(), boost::ref(info) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::DeathNotice( pVictim, info );
            }
        else
            this->C_HL2MPRules::DeathNotice( pVictim, info );
    }
    
    void default_DeathNotice( ::C_BasePlayer * pVictim, ::CTakeDamageInfo const & info ) {
        C_HL2MPRules::DeathNotice( pVictim, info );
    }

    virtual float FlWeaponRespawnTime( ::C_BaseCombatWeapon * pWeapon ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, FlWeaponRespawnTime )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, FlWeaponRespawnTime )
        bp::override func_FlWeaponRespawnTime = this->get_override( "FlWeaponRespawnTime" );
        if( func_FlWeaponRespawnTime.ptr() != Py_None )
            try {
                return func_FlWeaponRespawnTime( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::FlWeaponRespawnTime( pWeapon );
            }
        else
            return this->C_HL2MPRules::FlWeaponRespawnTime( pWeapon );
    }
    
    float default_FlWeaponRespawnTime( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::FlWeaponRespawnTime( pWeapon );
    }

    virtual float FlWeaponTryRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, FlWeaponTryRespawn )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, FlWeaponTryRespawn )
        bp::override func_FlWeaponTryRespawn = this->get_override( "FlWeaponTryRespawn" );
        if( func_FlWeaponTryRespawn.ptr() != Py_None )
            try {
                return func_FlWeaponTryRespawn( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::FlWeaponTryRespawn( pWeapon );
            }
        else
            return this->C_HL2MPRules::FlWeaponTryRespawn( pWeapon );
    }
    
    float default_FlWeaponTryRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::FlWeaponTryRespawn( pWeapon );
    }

    virtual char const * GetGameDescription(  ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, GetGameDescription )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, GetGameDescription )
        bp::override func_GetGameDescription = this->get_override( "GetGameDescription" );
        if( func_GetGameDescription.ptr() != Py_None )
            try {
                return func_GetGameDescription(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::GetGameDescription(  );
            }
        else
            return this->C_HL2MPRules::GetGameDescription(  );
    }
    
    char const * default_GetGameDescription(  ) {
        return C_HL2MPRules::GetGameDescription( );
    }

    virtual void GoToIntermission(  ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, GoToIntermission )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, GoToIntermission )
        bp::override func_GoToIntermission = this->get_override( "GoToIntermission" );
        if( func_GoToIntermission.ptr() != Py_None )
            try {
                func_GoToIntermission(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::GoToIntermission(  );
            }
        else
            this->C_HL2MPRules::GoToIntermission(  );
    }
    
    void default_GoToIntermission(  ) {
        C_HL2MPRules::GoToIntermission( );
    }

    virtual bool IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, IsConnectedUserInfoChangeAllowed )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, IsConnectedUserInfoChangeAllowed )
        bp::override func_IsConnectedUserInfoChangeAllowed = this->get_override( "IsConnectedUserInfoChangeAllowed" );
        if( func_IsConnectedUserInfoChangeAllowed.ptr() != Py_None )
            try {
                return func_IsConnectedUserInfoChangeAllowed( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::IsConnectedUserInfoChangeAllowed( pPlayer );
            }
        else
            return this->C_HL2MPRules::IsConnectedUserInfoChangeAllowed( pPlayer );
    }
    
    bool default_IsConnectedUserInfoChangeAllowed( ::C_BasePlayer * pPlayer ) {
        return C_HL2MPRules::IsConnectedUserInfoChangeAllowed( pPlayer );
    }

    virtual int PlayerRelationship( ::C_BaseEntity * pPlayer, ::C_BaseEntity * pTarget ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, PlayerRelationship )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, PlayerRelationship )
        bp::override func_PlayerRelationship = this->get_override( "PlayerRelationship" );
        if( func_PlayerRelationship.ptr() != Py_None )
            try {
                return func_PlayerRelationship( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pTarget ? pTarget->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::PlayerRelationship( pPlayer, pTarget );
            }
        else
            return this->C_HL2MPRules::PlayerRelationship( pPlayer, pTarget );
    }
    
    int default_PlayerRelationship( ::C_BaseEntity * pPlayer, ::C_BaseEntity * pTarget ) {
        return C_HL2MPRules::PlayerRelationship( pPlayer, pTarget );
    }

    virtual void Precache(  ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, Precache )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, Precache )
        bp::override func_Precache = this->get_override( "Precache" );
        if( func_Precache.ptr() != Py_None )
            try {
                func_Precache(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::Precache(  );
            }
        else
            this->C_HL2MPRules::Precache(  );
    }
    
    void default_Precache(  ) {
        C_HL2MPRules::Precache( );
    }

    virtual void Think(  ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, Think )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, Think )
        bp::override func_Think = this->get_override( "Think" );
        if( func_Think.ptr() != Py_None )
            try {
                func_Think(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_HL2MPRules::Think(  );
            }
        else
            this->C_HL2MPRules::Think(  );
    }
    
    void default_Think(  ) {
        C_HL2MPRules::Think( );
    }

    virtual ::Vector VecWeaponRespawnSpot( ::C_BaseCombatWeapon * pWeapon ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, VecWeaponRespawnSpot )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, VecWeaponRespawnSpot )
        bp::override func_VecWeaponRespawnSpot = this->get_override( "VecWeaponRespawnSpot" );
        if( func_VecWeaponRespawnSpot.ptr() != Py_None )
            try {
                return func_VecWeaponRespawnSpot( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::VecWeaponRespawnSpot( pWeapon );
            }
        else
            return this->C_HL2MPRules::VecWeaponRespawnSpot( pWeapon );
    }
    
    ::Vector default_VecWeaponRespawnSpot( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::VecWeaponRespawnSpot( pWeapon );
    }

    virtual int WeaponShouldRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        PY_OVERRIDE_CHECK( C_HL2MPRules, WeaponShouldRespawn )
        PY_OVERRIDE_LOG( _gamerules, C_HL2MPRules, WeaponShouldRespawn )
        bp::override func_WeaponShouldRespawn = this->get_override( "WeaponShouldRespawn" );
        if( func_WeaponShouldRespawn.ptr() != Py_None )
            try {
                return func_WeaponShouldRespawn( pWeapon ? pWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_HL2MPRules::WeaponShouldRespawn( pWeapon );
            }
        else
            return this->C_HL2MPRules::WeaponShouldRespawn( pWeapon );
    }
    
    int default_WeaponShouldRespawn( ::C_BaseCombatWeapon * pWeapon ) {
        return C_HL2MPRules::WeaponShouldRespawn( pWeapon );
    }

    virtual bool AllowMapParticleEffect( char const * pszParticleEffect ) {
        PY_OVERRIDE_CHECK( C_GameRules, AllowMapParticleEffect )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, AllowMapParticleEffect )
        bp::override func_AllowMapParticleEffect = this->get_override( "AllowMapParticleEffect" );
        if( func_AllowMapParticleEffect.ptr() != Py_None )
            try {
                return func_AllowMapParticleEffect( pszParticleEffect );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
            }
        else
            return this->C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }
    
    bool default_AllowMapParticleEffect( char const * pszParticleEffect ) {
        return C_GameRules::AllowMapParticleEffect( pszParticleEffect );
    }

    virtual bool AllowMapVisionFilterShaders(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, AllowMapVisionFilterShaders )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, AllowMapVisionFilterShaders )
        bp::override func_AllowMapVisionFilterShaders = this->get_override( "AllowMapVisionFilterShaders" );
        if( func_AllowMapVisionFilterShaders.ptr() != Py_None )
            try {
                return func_AllowMapVisionFilterShaders(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowMapVisionFilterShaders(  );
            }
        else
            return this->C_GameRules::AllowMapVisionFilterShaders(  );
    }
    
    bool default_AllowMapVisionFilterShaders(  ) {
        return C_GameRules::AllowMapVisionFilterShaders( );
    }

    virtual bool AllowThirdPersonCamera(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, AllowThirdPersonCamera )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, AllowThirdPersonCamera )
        bp::override func_AllowThirdPersonCamera = this->get_override( "AllowThirdPersonCamera" );
        if( func_AllowThirdPersonCamera.ptr() != Py_None )
            try {
                return func_AllowThirdPersonCamera(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowThirdPersonCamera(  );
            }
        else
            return this->C_GameRules::AllowThirdPersonCamera(  );
    }
    
    bool default_AllowThirdPersonCamera(  ) {
        return C_GameRules::AllowThirdPersonCamera( );
    }

    virtual bool AllowWeatherParticles(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, AllowWeatherParticles )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, AllowWeatherParticles )
        bp::override func_AllowWeatherParticles = this->get_override( "AllowWeatherParticles" );
        if( func_AllowWeatherParticles.ptr() != Py_None )
            try {
                return func_AllowWeatherParticles(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::AllowWeatherParticles(  );
            }
        else
            return this->C_GameRules::AllowWeatherParticles(  );
    }
    
    bool default_AllowWeatherParticles(  ) {
        return C_GameRules::AllowWeatherParticles( );
    }

    virtual void ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        PY_OVERRIDE_CHECK( C_GameRules, ClientCommandKeyValues )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, ClientCommandKeyValues )
        bp::override func_ClientCommandKeyValues = this->get_override( "ClientCommandKeyValues" );
        if( func_ClientCommandKeyValues.ptr() != Py_None )
            try {
                func_ClientCommandKeyValues( boost::python::ptr(pEntity), boost::python::ptr(pKeyValues) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientCommandKeyValues( pEntity, pKeyValues );
            }
        else
            this->C_GameRules::ClientCommandKeyValues( pEntity, pKeyValues );
    }
    
    void default_ClientCommandKeyValues( ::edict_t * pEntity, ::KeyValues * pKeyValues ) {
        C_GameRules::ClientCommandKeyValues( pEntity, pKeyValues );
    }

    virtual void ClientSpawned( ::edict_t * pPlayer ) {
        PY_OVERRIDE_CHECK( C_GameRules, ClientSpawned )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, ClientSpawned )
        bp::override func_ClientSpawned = this->get_override( "ClientSpawned" );
        if( func_ClientSpawned.ptr() != Py_None )
            try {
                func_ClientSpawned( boost::python::ptr(pPlayer) );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ClientSpawned( pPlayer );
            }
        else
            this->C_GameRules::ClientSpawned( pPlayer );
    }
    
    void default_ClientSpawned( ::edict_t * pPlayer ) {
        C_GameRules::ClientSpawned( pPlayer );
    }

    virtual int Damage_GetNoPhysicsForce(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_GetNoPhysicsForce )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_GetNoPhysicsForce )
        bp::override func_Damage_GetNoPhysicsForce = this->get_override( "Damage_GetNoPhysicsForce" );
        if( func_Damage_GetNoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_GetNoPhysicsForce(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetNoPhysicsForce(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetNoPhysicsForce(  );
    }
    
    int default_Damage_GetNoPhysicsForce(  ) {
        return C_MultiplayRules::Damage_GetNoPhysicsForce( );
    }

    virtual int Damage_GetShouldGibCorpse(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_GetShouldGibCorpse )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_GetShouldGibCorpse )
        bp::override func_Damage_GetShouldGibCorpse = this->get_override( "Damage_GetShouldGibCorpse" );
        if( func_Damage_GetShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_GetShouldGibCorpse(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShouldGibCorpse(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShouldGibCorpse(  );
    }
    
    int default_Damage_GetShouldGibCorpse(  ) {
        return C_MultiplayRules::Damage_GetShouldGibCorpse( );
    }

    virtual int Damage_GetShouldNotBleed(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_GetShouldNotBleed )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_GetShouldNotBleed )
        bp::override func_Damage_GetShouldNotBleed = this->get_override( "Damage_GetShouldNotBleed" );
        if( func_Damage_GetShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_GetShouldNotBleed(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShouldNotBleed(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShouldNotBleed(  );
    }
    
    int default_Damage_GetShouldNotBleed(  ) {
        return C_MultiplayRules::Damage_GetShouldNotBleed( );
    }

    virtual int Damage_GetShowOnHud(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_GetShowOnHud )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_GetShowOnHud )
        bp::override func_Damage_GetShowOnHud = this->get_override( "Damage_GetShowOnHud" );
        if( func_Damage_GetShowOnHud.ptr() != Py_None )
            try {
                return func_Damage_GetShowOnHud(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetShowOnHud(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetShowOnHud(  );
    }
    
    int default_Damage_GetShowOnHud(  ) {
        return C_MultiplayRules::Damage_GetShowOnHud( );
    }

    virtual int Damage_GetTimeBased(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_GetTimeBased )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_GetTimeBased )
        bp::override func_Damage_GetTimeBased = this->get_override( "Damage_GetTimeBased" );
        if( func_Damage_GetTimeBased.ptr() != Py_None )
            try {
                return func_Damage_GetTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_GetTimeBased(  );
            }
        else
            return this->C_MultiplayRules::Damage_GetTimeBased(  );
    }
    
    int default_Damage_GetTimeBased(  ) {
        return C_MultiplayRules::Damage_GetTimeBased( );
    }

    virtual bool Damage_IsTimeBased( int iDmgType ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_IsTimeBased )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_IsTimeBased )
        bp::override func_Damage_IsTimeBased = this->get_override( "Damage_IsTimeBased" );
        if( func_Damage_IsTimeBased.ptr() != Py_None )
            try {
                return func_Damage_IsTimeBased( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_IsTimeBased( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_IsTimeBased( iDmgType );
    }
    
    bool default_Damage_IsTimeBased( int iDmgType ) {
        return C_MultiplayRules::Damage_IsTimeBased( iDmgType );
    }

    virtual bool Damage_NoPhysicsForce( int iDmgType ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_NoPhysicsForce )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_NoPhysicsForce )
        bp::override func_Damage_NoPhysicsForce = this->get_override( "Damage_NoPhysicsForce" );
        if( func_Damage_NoPhysicsForce.ptr() != Py_None )
            try {
                return func_Damage_NoPhysicsForce( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }
    
    bool default_Damage_NoPhysicsForce( int iDmgType ) {
        return C_MultiplayRules::Damage_NoPhysicsForce( iDmgType );
    }

    virtual bool Damage_ShouldGibCorpse( int iDmgType ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_ShouldGibCorpse )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_ShouldGibCorpse )
        bp::override func_Damage_ShouldGibCorpse = this->get_override( "Damage_ShouldGibCorpse" );
        if( func_Damage_ShouldGibCorpse.ptr() != Py_None )
            try {
                return func_Damage_ShouldGibCorpse( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }
    
    bool default_Damage_ShouldGibCorpse( int iDmgType ) {
        return C_MultiplayRules::Damage_ShouldGibCorpse( iDmgType );
    }

    virtual bool Damage_ShouldNotBleed( int iDmgType ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_ShouldNotBleed )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_ShouldNotBleed )
        bp::override func_Damage_ShouldNotBleed = this->get_override( "Damage_ShouldNotBleed" );
        if( func_Damage_ShouldNotBleed.ptr() != Py_None )
            try {
                return func_Damage_ShouldNotBleed( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }
    
    bool default_Damage_ShouldNotBleed( int iDmgType ) {
        return C_MultiplayRules::Damage_ShouldNotBleed( iDmgType );
    }

    virtual bool Damage_ShowOnHUD( int iDmgType ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Damage_ShowOnHUD )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Damage_ShowOnHUD )
        bp::override func_Damage_ShowOnHUD = this->get_override( "Damage_ShowOnHUD" );
        if( func_Damage_ShowOnHUD.ptr() != Py_None )
            try {
                return func_Damage_ShowOnHUD( iDmgType );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
            }
        else
            return this->C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
    }
    
    bool default_Damage_ShowOnHUD( int iDmgType ) {
        return C_MultiplayRules::Damage_ShowOnHUD( iDmgType );
    }

    virtual int DefaultFOV(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, DefaultFOV )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, DefaultFOV )
        bp::override func_DefaultFOV = this->get_override( "DefaultFOV" );
        if( func_DefaultFOV.ptr() != Py_None )
            try {
                return func_DefaultFOV(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::DefaultFOV(  );
            }
        else
            return this->C_GameRules::DefaultFOV(  );
    }
    
    int default_DefaultFOV(  ) {
        return C_GameRules::DefaultFOV( );
    }

    virtual int GetCaptureValueForPlayer( ::C_BasePlayer * pPlayer ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, GetCaptureValueForPlayer )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, GetCaptureValueForPlayer )
        bp::override func_GetCaptureValueForPlayer = this->get_override( "GetCaptureValueForPlayer" );
        if( func_GetCaptureValueForPlayer.ptr() != Py_None )
            try {
                return func_GetCaptureValueForPlayer( pPlayer ? pPlayer->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::GetCaptureValueForPlayer( pPlayer );
            }
        else
            return this->C_TeamplayRules::GetCaptureValueForPlayer( pPlayer );
    }
    
    int default_GetCaptureValueForPlayer( ::C_BasePlayer * pPlayer ) {
        return C_TeamplayRules::GetCaptureValueForPlayer( pPlayer );
    }

    virtual float GetDamageMultiplier(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, GetDamageMultiplier )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, GetDamageMultiplier )
        bp::override func_GetDamageMultiplier = this->get_override( "GetDamageMultiplier" );
        if( func_GetDamageMultiplier.ptr() != Py_None )
            try {
                return func_GetDamageMultiplier(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetDamageMultiplier(  );
            }
        else
            return this->C_GameRules::GetDamageMultiplier(  );
    }
    
    float default_GetDamageMultiplier(  ) {
        return C_GameRules::GetDamageMultiplier( );
    }

    virtual int GetGameType(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, GetGameType )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, GetGameType )
        bp::override func_GetGameType = this->get_override( "GetGameType" );
        if( func_GetGameType.ptr() != Py_None )
            try {
                return func_GetGameType(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameType(  );
            }
        else
            return this->C_GameRules::GetGameType(  );
    }
    
    int default_GetGameType(  ) {
        return C_GameRules::GetGameType( );
    }

    virtual char const * GetGameTypeName(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, GetGameTypeName )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, GetGameTypeName )
        bp::override func_GetGameTypeName = this->get_override( "GetGameTypeName" );
        if( func_GetGameTypeName.ptr() != Py_None )
            try {
                return func_GetGameTypeName(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetGameTypeName(  );
            }
        else
            return this->C_GameRules::GetGameTypeName(  );
    }
    
    char const * default_GetGameTypeName(  ) {
        return C_GameRules::GetGameTypeName( );
    }

    virtual ::C_BaseCombatWeapon * GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        PY_OVERRIDE_CHECK( C_GameRules, GetNextBestWeapon )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, GetNextBestWeapon )
        bp::override func_GetNextBestWeapon = this->get_override( "GetNextBestWeapon" );
        if( func_GetNextBestWeapon.ptr() != Py_None )
            try {
                return func_GetNextBestWeapon( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pCurrentWeapon ? pCurrentWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
            }
        else
            return this->C_GameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
    }
    
    ::C_BaseCombatWeapon * default_GetNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::GetNextBestWeapon( pPlayer, pCurrentWeapon );
    }

    virtual bool InRoundRestart(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, InRoundRestart )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, InRoundRestart )
        bp::override func_InRoundRestart = this->get_override( "InRoundRestart" );
        if( func_InRoundRestart.ptr() != Py_None )
            try {
                return func_InRoundRestart(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::InRoundRestart(  );
            }
        else
            return this->C_GameRules::InRoundRestart(  );
    }
    
    bool default_InRoundRestart(  ) {
        return C_GameRules::InRoundRestart( );
    }

    virtual bool Init(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, Init )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, Init )
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::Init(  );
            }
        else
            return this->C_MultiplayRules::Init(  );
    }
    
    bool default_Init(  ) {
        return C_MultiplayRules::Init( );
    }

    virtual void InitGamerules(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, InitGamerules )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, InitGamerules )
        bp::override func_InitGamerules = this->get_override( "InitGamerules" );
        if( func_InitGamerules.ptr() != Py_None )
            try {
                func_InitGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::InitGamerules(  );
            }
        else
            this->C_GameRules::InitGamerules(  );
    }
    
    void default_InitGamerules(  ) {
        C_GameRules::InitGamerules( );
    }

    virtual bool IsBonusChallengeTimeBased(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, IsBonusChallengeTimeBased )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, IsBonusChallengeTimeBased )
        bp::override func_IsBonusChallengeTimeBased = this->get_override( "IsBonusChallengeTimeBased" );
        if( func_IsBonusChallengeTimeBased.ptr() != Py_None )
            try {
                return func_IsBonusChallengeTimeBased(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsBonusChallengeTimeBased(  );
            }
        else
            return this->C_GameRules::IsBonusChallengeTimeBased(  );
    }
    
    bool default_IsBonusChallengeTimeBased(  ) {
        return C_GameRules::IsBonusChallengeTimeBased( );
    }

    virtual bool IsHolidayActive( int eHoliday ) const  {
        PY_OVERRIDE_CHECK( C_GameRules, IsHolidayActive )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, IsHolidayActive )
        bp::override func_IsHolidayActive = this->get_override( "IsHolidayActive" );
        if( func_IsHolidayActive.ptr() != Py_None )
            try {
                return func_IsHolidayActive( eHoliday );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsHolidayActive( eHoliday );
            }
        else
            return this->C_GameRules::IsHolidayActive( eHoliday );
    }
    
    bool default_IsHolidayActive( int eHoliday ) const  {
        return C_GameRules::IsHolidayActive( eHoliday );
    }

    virtual bool IsLocalPlayer( int nEntIndex ) {
        PY_OVERRIDE_CHECK( C_GameRules, IsLocalPlayer )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, IsLocalPlayer )
        bp::override func_IsLocalPlayer = this->get_override( "IsLocalPlayer" );
        if( func_IsLocalPlayer.ptr() != Py_None )
            try {
                return func_IsLocalPlayer( nEntIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsLocalPlayer( nEntIndex );
            }
        else
            return this->C_GameRules::IsLocalPlayer( nEntIndex );
    }
    
    bool default_IsLocalPlayer( int nEntIndex ) {
        return C_GameRules::IsLocalPlayer( nEntIndex );
    }

    virtual bool IsManualMapChangeOkay( char const * * pszReason ) {
        PY_OVERRIDE_CHECK( C_GameRules, IsManualMapChangeOkay )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, IsManualMapChangeOkay )
        bp::override func_IsManualMapChangeOkay = this->get_override( "IsManualMapChangeOkay" );
        if( func_IsManualMapChangeOkay.ptr() != Py_None )
            try {
                return func_IsManualMapChangeOkay( pszReason );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::IsManualMapChangeOkay( pszReason );
            }
        else
            return this->C_GameRules::IsManualMapChangeOkay( pszReason );
    }
    
    bool default_IsManualMapChangeOkay( char const * * pszReason ) {
        return C_GameRules::IsManualMapChangeOkay( pszReason );
    }

    virtual bool IsMultiplayer(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, IsMultiplayer )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, IsMultiplayer )
        bp::override func_IsMultiplayer = this->get_override( "IsMultiplayer" );
        if( func_IsMultiplayer.ptr() != Py_None )
            try {
                return func_IsMultiplayer(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::IsMultiplayer(  );
            }
        else
            return this->C_MultiplayRules::IsMultiplayer(  );
    }
    
    bool default_IsMultiplayer(  ) {
        return C_MultiplayRules::IsMultiplayer( );
    }

    virtual void ModifySentChat( char * pBuf, int iBufSize ) {
        PY_OVERRIDE_CHECK( C_GameRules, ModifySentChat )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, ModifySentChat )
        bp::override func_ModifySentChat = this->get_override( "ModifySentChat" );
        if( func_ModifySentChat.ptr() != Py_None )
            try {
                func_ModifySentChat( pBuf, iBufSize );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ModifySentChat( pBuf, iBufSize );
            }
        else
            this->C_GameRules::ModifySentChat( pBuf, iBufSize );
    }
    
    void default_ModifySentChat( char * pBuf, int iBufSize ) {
        C_GameRules::ModifySentChat( pBuf, iBufSize );
    }

    virtual char const * Name(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, Name )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, Name )
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::Name(  );
            }
        else
            return this->C_GameRules::Name(  );
    }
    
    char const * default_Name(  ) {
        return C_GameRules::Name( );
    }

    virtual void OnFileReceived( char const * fileName, unsigned int transferID ) {
        PY_OVERRIDE_CHECK( C_GameRules, OnFileReceived )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, OnFileReceived )
        bp::override func_OnFileReceived = this->get_override( "OnFileReceived" );
        if( func_OnFileReceived.ptr() != Py_None )
            try {
                func_OnFileReceived( fileName, transferID );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::OnFileReceived( fileName, transferID );
            }
        else
            this->C_GameRules::OnFileReceived( fileName, transferID );
    }
    
    void default_OnFileReceived( char const * fileName, unsigned int transferID ) {
        C_GameRules::OnFileReceived( fileName, transferID );
    }

    virtual bool PlayerMayBlockPoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, PlayerMayBlockPoint )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, PlayerMayBlockPoint )
        bp::override func_PlayerMayBlockPoint = this->get_override( "PlayerMayBlockPoint" );
        if( func_PlayerMayBlockPoint.ptr() != Py_None )
            try {
                return func_PlayerMayBlockPoint( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), iPointIndex, pszReason, iMaxReasonLength );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PlayerMayBlockPoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
            }
        else
            return this->C_TeamplayRules::PlayerMayBlockPoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
    }
    
    bool default_PlayerMayBlockPoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        return C_TeamplayRules::PlayerMayBlockPoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
    }

    virtual bool PlayerMayCapturePoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, PlayerMayCapturePoint )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, PlayerMayCapturePoint )
        bp::override func_PlayerMayCapturePoint = this->get_override( "PlayerMayCapturePoint" );
        if( func_PlayerMayCapturePoint.ptr() != Py_None )
            try {
                return func_PlayerMayCapturePoint( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), iPointIndex, pszReason, iMaxReasonLength );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PlayerMayCapturePoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
            }
        else
            return this->C_TeamplayRules::PlayerMayCapturePoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
    }
    
    bool default_PlayerMayCapturePoint( ::C_BasePlayer * pPlayer, int iPointIndex, char * pszReason=0, int iMaxReasonLength=0 ) {
        return C_TeamplayRules::PlayerMayCapturePoint( pPlayer, iPointIndex, pszReason, iMaxReasonLength );
    }

    virtual bool PointsMayBeCaptured(  ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, PointsMayBeCaptured )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, PointsMayBeCaptured )
        bp::override func_PointsMayBeCaptured = this->get_override( "PointsMayBeCaptured" );
        if( func_PointsMayBeCaptured.ptr() != Py_None )
            try {
                return func_PointsMayBeCaptured(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::PointsMayBeCaptured(  );
            }
        else
            return this->C_TeamplayRules::PointsMayBeCaptured(  );
    }
    
    bool default_PointsMayBeCaptured(  ) {
        return C_TeamplayRules::PointsMayBeCaptured( );
    }

    virtual void SetLastCapPointChanged( int iIndex ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, SetLastCapPointChanged )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, SetLastCapPointChanged )
        bp::override func_SetLastCapPointChanged = this->get_override( "SetLastCapPointChanged" );
        if( func_SetLastCapPointChanged.ptr() != Py_None )
            try {
                func_SetLastCapPointChanged( iIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_TeamplayRules::SetLastCapPointChanged( iIndex );
            }
        else
            this->C_TeamplayRules::SetLastCapPointChanged( iIndex );
    }
    
    void default_SetLastCapPointChanged( int iIndex ) {
        C_TeamplayRules::SetLastCapPointChanged( iIndex );
    }

    virtual bool ShouldDrawHeadLabels(  ) {
        PY_OVERRIDE_CHECK( C_MultiplayRules, ShouldDrawHeadLabels )
        PY_OVERRIDE_LOG( _gamerules, C_MultiplayRules, ShouldDrawHeadLabels )
        bp::override func_ShouldDrawHeadLabels = this->get_override( "ShouldDrawHeadLabels" );
        if( func_ShouldDrawHeadLabels.ptr() != Py_None )
            try {
                return func_ShouldDrawHeadLabels(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_MultiplayRules::ShouldDrawHeadLabels(  );
            }
        else
            return this->C_MultiplayRules::ShouldDrawHeadLabels(  );
    }
    
    bool default_ShouldDrawHeadLabels(  ) {
        return C_MultiplayRules::ShouldDrawHeadLabels( );
    }

    virtual bool ShouldWarnOfAbandonOnQuit(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, ShouldWarnOfAbandonOnQuit )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, ShouldWarnOfAbandonOnQuit )
        bp::override func_ShouldWarnOfAbandonOnQuit = this->get_override( "ShouldWarnOfAbandonOnQuit" );
        if( func_ShouldWarnOfAbandonOnQuit.ptr() != Py_None )
            try {
                return func_ShouldWarnOfAbandonOnQuit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
            }
        else
            return this->C_GameRules::ShouldWarnOfAbandonOnQuit(  );
    }
    
    bool default_ShouldWarnOfAbandonOnQuit(  ) {
        return C_GameRules::ShouldWarnOfAbandonOnQuit( );
    }

    virtual void ShutdownGamerules(  ) {
        PY_OVERRIDE_CHECK( C_GameRules, ShutdownGamerules )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, ShutdownGamerules )
        bp::override func_ShutdownGamerules = this->get_override( "ShutdownGamerules" );
        if( func_ShutdownGamerules.ptr() != Py_None )
            try {
                func_ShutdownGamerules(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->C_GameRules::ShutdownGamerules(  );
            }
        else
            this->C_GameRules::ShutdownGamerules(  );
    }
    
    void default_ShutdownGamerules(  ) {
        C_GameRules::ShutdownGamerules( );
    }

    virtual bool SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        PY_OVERRIDE_CHECK( C_GameRules, SwitchToNextBestWeapon )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, SwitchToNextBestWeapon )
        bp::override func_SwitchToNextBestWeapon = this->get_override( "SwitchToNextBestWeapon" );
        if( func_SwitchToNextBestWeapon.ptr() != Py_None )
            try {
                return func_SwitchToNextBestWeapon( pPlayer ? pPlayer->GetPyHandle() : boost::python::object(), pCurrentWeapon ? pCurrentWeapon->GetPyHandle() : boost::python::object() );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
            }
        else
            return this->C_GameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
    }
    
    bool default_SwitchToNextBestWeapon( ::C_BaseCombatCharacter * pPlayer, ::C_BaseCombatWeapon * pCurrentWeapon ) {
        return C_GameRules::SwitchToNextBestWeapon( pPlayer, pCurrentWeapon );
    }

    virtual bool TeamMayCapturePoint( int iTeam, int iPointIndex ) {
        PY_OVERRIDE_CHECK( C_TeamplayRules, TeamMayCapturePoint )
        PY_OVERRIDE_LOG( _gamerules, C_TeamplayRules, TeamMayCapturePoint )
        bp::override func_TeamMayCapturePoint = this->get_override( "TeamMayCapturePoint" );
        if( func_TeamMayCapturePoint.ptr() != Py_None )
            try {
                return func_TeamMayCapturePoint( iTeam, iPointIndex );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
            }
        else
            return this->C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
    }
    
    bool default_TeamMayCapturePoint( int iTeam, int iPointIndex ) {
        return C_TeamplayRules::TeamMayCapturePoint( iTeam, iPointIndex );
    }

    virtual char const * TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        PY_OVERRIDE_CHECK( C_GameRules, TranslateEffectForVisionFilter )
        PY_OVERRIDE_LOG( _gamerules, C_GameRules, TranslateEffectForVisionFilter )
        bp::override func_TranslateEffectForVisionFilter = this->get_override( "TranslateEffectForVisionFilter" );
        if( func_TranslateEffectForVisionFilter.ptr() != Py_None )
            try {
                return func_TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
            }
        else
            return this->C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }
    
    char const * default_TranslateEffectForVisionFilter( char const * pchEffectType, char const * pchEffectName ) {
        return C_GameRules::TranslateEffectForVisionFilter( pchEffectType, pchEffectName );
    }

    virtual PyObject *GetPySelf() const { return boost::python::detail::wrapper_base_::get_owner(*this); }

};

void register_CHL2MPRules_class(){

    bp::class_< C_HL2MPRules_wrapper, bp::bases< C_TeamplayRules >, boost::noncopyable >( "CHL2MPRules", bp::no_init )    
        .def( bp::init< >() )    
        .def( 
            "CheckGameOver"
            , (bool ( ::C_HL2MPRules::* )(  ))( &::C_HL2MPRules::CheckGameOver ) )    
        .def( 
            "ClientCommand"
            , (bool ( ::C_HL2MPRules::* )( ::C_BaseEntity *,::CCommand const & ))(&::C_HL2MPRules::ClientCommand)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BaseEntity *,::CCommand const & ))(&C_HL2MPRules_wrapper::default_ClientCommand)
            , ( bp::arg("pEdict"), bp::arg("args") ) )    
        .def( 
            "ClientDisconnected"
            , (void ( ::C_HL2MPRules::* )( ::edict_t * ))(&::C_HL2MPRules::ClientDisconnected)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t * ))(&C_HL2MPRules_wrapper::default_ClientDisconnected)
            , ( bp::arg("pClient") ) )    
        .def( 
            "ClientSettingsChanged"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer * ))(&::C_HL2MPRules::ClientSettingsChanged)
            , (void ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ))(&C_HL2MPRules_wrapper::default_ClientSettingsChanged)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "CreateStandardEntities"
            , (void ( ::C_HL2MPRules::* )(  ))(&::C_HL2MPRules::CreateStandardEntities)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_CreateStandardEntities) )    
        .def( 
            "DeathNotice"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ))(&::C_HL2MPRules::DeathNotice)
            , (void ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ))(&C_HL2MPRules_wrapper::default_DeathNotice)
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "FlWeaponRespawnTime"
            , (float ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ))(&::C_HL2MPRules::FlWeaponRespawnTime)
            , (float ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_FlWeaponRespawnTime)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "FlWeaponTryRespawn"
            , (float ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ))(&::C_HL2MPRules::FlWeaponTryRespawn)
            , (float ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_FlWeaponTryRespawn)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "GetGameDescription"
            , (char const * ( ::C_HL2MPRules::* )(  ))(&::C_HL2MPRules::GetGameDescription)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_GetGameDescription) )    
        .def( 
            "GetMapRemainingTime"
            , (float ( ::C_HL2MPRules::* )(  ))( &::C_HL2MPRules::GetMapRemainingTime ) )    
        .def( 
            "GoToIntermission"
            , (void ( ::C_HL2MPRules::* )(  ))(&::C_HL2MPRules::GoToIntermission)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_GoToIntermission) )    
        .def( 
            "IsConnectedUserInfoChangeAllowed"
            , (bool ( ::C_HL2MPRules::* )( ::C_BasePlayer * ))(&::C_HL2MPRules::IsConnectedUserInfoChangeAllowed)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ))(&C_HL2MPRules_wrapper::default_IsConnectedUserInfoChangeAllowed)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "IsIntermission"
            , (bool ( ::C_HL2MPRules::* )(  ))( &::C_HL2MPRules::IsIntermission ) )    
        .def( 
            "IsTeamplay"
            , (bool ( ::C_HL2MPRules::* )(  ))( &::C_HL2MPRules::IsTeamplay ) )    
        .def( 
            "PlayerKilled"
            , (void ( ::C_HL2MPRules::* )( ::C_BasePlayer *,::CTakeDamageInfo const & ))( &::C_HL2MPRules::PlayerKilled )
            , ( bp::arg("pVictim"), bp::arg("info") ) )    
        .def( 
            "PlayerRelationship"
            , (int ( ::C_HL2MPRules::* )( ::C_BaseEntity *,::C_BaseEntity * ))(&::C_HL2MPRules::PlayerRelationship)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BaseEntity *,::C_BaseEntity * ))(&C_HL2MPRules_wrapper::default_PlayerRelationship)
            , ( bp::arg("pPlayer"), bp::arg("pTarget") ) )    
        .def( 
            "Precache"
            , (void ( ::C_HL2MPRules::* )(  ))(&::C_HL2MPRules::Precache)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Precache) )    
        .def( 
            "ShouldCollide"
            , (bool ( ::C_HL2MPRules::* )( int,int ))( &::C_HL2MPRules::ShouldCollide )
            , ( bp::arg("collisionGroup0"), bp::arg("collisionGroup1") ) )    
        .def( 
            "Think"
            , (void ( ::C_HL2MPRules::* )(  ))(&::C_HL2MPRules::Think)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Think) )    
        .def( 
            "VecWeaponRespawnSpot"
            , (::Vector ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ))(&::C_HL2MPRules::VecWeaponRespawnSpot)
            , (::Vector ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_VecWeaponRespawnSpot)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "WeaponShouldRespawn"
            , (int ( ::C_HL2MPRules::* )( ::C_BaseCombatWeapon * ))(&::C_HL2MPRules::WeaponShouldRespawn)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_WeaponShouldRespawn)
            , ( bp::arg("pWeapon") ) )    
        .def( 
            "AllowMapParticleEffect"
            , (bool ( ::C_GameRules::* )( char const * ))(&::C_GameRules::AllowMapParticleEffect)
            , (bool ( C_HL2MPRules_wrapper::* )( char const * ))(&C_HL2MPRules_wrapper::default_AllowMapParticleEffect)
            , ( bp::arg("pszParticleEffect") ) )    
        .def( 
            "AllowMapVisionFilterShaders"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::AllowMapVisionFilterShaders)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_AllowMapVisionFilterShaders) )    
        .def( 
            "AllowThirdPersonCamera"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::AllowThirdPersonCamera)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_AllowThirdPersonCamera) )    
        .def( 
            "AllowWeatherParticles"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::AllowWeatherParticles)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_AllowWeatherParticles) )    
        .def( 
            "ClientCommandKeyValues"
            , (void ( ::C_GameRules::* )( ::edict_t *,::KeyValues * ))(&::C_GameRules::ClientCommandKeyValues)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t *,::KeyValues * ))(&C_HL2MPRules_wrapper::default_ClientCommandKeyValues)
            , ( bp::arg("pEntity"), bp::arg("pKeyValues") ) )    
        .def( 
            "ClientSpawned"
            , (void ( ::C_GameRules::* )( ::edict_t * ))(&::C_GameRules::ClientSpawned)
            , (void ( C_HL2MPRules_wrapper::* )( ::edict_t * ))(&C_HL2MPRules_wrapper::default_ClientSpawned)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "Damage_GetNoPhysicsForce"
            , (int ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Damage_GetNoPhysicsForce)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Damage_GetNoPhysicsForce) )    
        .def( 
            "Damage_GetShouldGibCorpse"
            , (int ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Damage_GetShouldGibCorpse)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Damage_GetShouldGibCorpse) )    
        .def( 
            "Damage_GetShouldNotBleed"
            , (int ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Damage_GetShouldNotBleed)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Damage_GetShouldNotBleed) )    
        .def( 
            "Damage_GetShowOnHud"
            , (int ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Damage_GetShowOnHud)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Damage_GetShowOnHud) )    
        .def( 
            "Damage_GetTimeBased"
            , (int ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Damage_GetTimeBased)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Damage_GetTimeBased) )    
        .def( 
            "Damage_IsTimeBased"
            , (bool ( ::C_MultiplayRules::* )( int ))(&::C_MultiplayRules::Damage_IsTimeBased)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_Damage_IsTimeBased)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_NoPhysicsForce"
            , (bool ( ::C_MultiplayRules::* )( int ))(&::C_MultiplayRules::Damage_NoPhysicsForce)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_Damage_NoPhysicsForce)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldGibCorpse"
            , (bool ( ::C_MultiplayRules::* )( int ))(&::C_MultiplayRules::Damage_ShouldGibCorpse)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_Damage_ShouldGibCorpse)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShouldNotBleed"
            , (bool ( ::C_MultiplayRules::* )( int ))(&::C_MultiplayRules::Damage_ShouldNotBleed)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_Damage_ShouldNotBleed)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "Damage_ShowOnHUD"
            , (bool ( ::C_MultiplayRules::* )( int ))(&::C_MultiplayRules::Damage_ShowOnHUD)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_Damage_ShowOnHUD)
            , ( bp::arg("iDmgType") ) )    
        .def( 
            "DefaultFOV"
            , (int ( ::C_GameRules::* )(  ))(&::C_GameRules::DefaultFOV)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_DefaultFOV) )    
        .def( 
            "GetCaptureValueForPlayer"
            , (int ( ::C_TeamplayRules::* )( ::C_BasePlayer * ))(&::C_TeamplayRules::GetCaptureValueForPlayer)
            , (int ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer * ))(&C_HL2MPRules_wrapper::default_GetCaptureValueForPlayer)
            , ( bp::arg("pPlayer") ) )    
        .def( 
            "GetDamageMultiplier"
            , (float ( ::C_GameRules::* )(  ))(&::C_GameRules::GetDamageMultiplier)
            , (float ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_GetDamageMultiplier) )    
        .def( 
            "GetGameType"
            , (int ( ::C_GameRules::* )(  ))(&::C_GameRules::GetGameType)
            , (int ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_GetGameType) )    
        .def( 
            "GetGameTypeName"
            , (char const * ( ::C_GameRules::* )(  ))(&::C_GameRules::GetGameTypeName)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_GetGameTypeName) )    
        .def( 
            "GetNextBestWeapon"
            , (::C_BaseCombatWeapon * ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ))(&::C_GameRules::GetNextBestWeapon)
            , (::C_BaseCombatWeapon * ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_GetNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "InRoundRestart"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::InRoundRestart)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_InRoundRestart) )    
        .def( 
            "Init"
            , (bool ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::Init)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Init) )    
        .def( 
            "InitGamerules"
            , (void ( ::C_GameRules::* )(  ))(&::C_GameRules::InitGamerules)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_InitGamerules) )    
        .def( 
            "IsBonusChallengeTimeBased"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::IsBonusChallengeTimeBased)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_IsBonusChallengeTimeBased) )    
        .def( 
            "IsHolidayActive"
            , (bool ( ::C_GameRules::* )( int )const)(&::C_GameRules::IsHolidayActive)
            , (bool ( C_HL2MPRules_wrapper::* )( int )const)(&C_HL2MPRules_wrapper::default_IsHolidayActive)
            , ( bp::arg("eHoliday") ) )    
        .def( 
            "IsLocalPlayer"
            , (bool ( ::C_GameRules::* )( int ))(&::C_GameRules::IsLocalPlayer)
            , (bool ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_IsLocalPlayer)
            , ( bp::arg("nEntIndex") ) )    
        .def( 
            "IsManualMapChangeOkay"
            , (bool ( ::C_GameRules::* )( char const * * ))(&::C_GameRules::IsManualMapChangeOkay)
            , (bool ( C_HL2MPRules_wrapper::* )( char const * * ))(&C_HL2MPRules_wrapper::default_IsManualMapChangeOkay)
            , ( bp::arg("pszReason") ) )    
        .def( 
            "IsMultiplayer"
            , (bool ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::IsMultiplayer)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_IsMultiplayer) )    
        .def( 
            "ModifySentChat"
            , (void ( ::C_GameRules::* )( char *,int ))(&::C_GameRules::ModifySentChat)
            , (void ( C_HL2MPRules_wrapper::* )( char *,int ))(&C_HL2MPRules_wrapper::default_ModifySentChat)
            , ( bp::arg("pBuf"), bp::arg("iBufSize") ) )    
        .def( 
            "Name"
            , (char const * ( ::C_GameRules::* )(  ))(&::C_GameRules::Name)
            , (char const * ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_Name) )    
        .def( 
            "OnFileReceived"
            , (void ( ::C_GameRules::* )( char const *,unsigned int ))(&::C_GameRules::OnFileReceived)
            , (void ( C_HL2MPRules_wrapper::* )( char const *,unsigned int ))(&C_HL2MPRules_wrapper::default_OnFileReceived)
            , ( bp::arg("fileName"), bp::arg("transferID") ) )    
        .def( 
            "PlayerMayBlockPoint"
            , (bool ( ::C_TeamplayRules::* )( ::C_BasePlayer *,int,char *,int ))(&::C_TeamplayRules::PlayerMayBlockPoint)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,int,char *,int ))(&C_HL2MPRules_wrapper::default_PlayerMayBlockPoint)
            , ( bp::arg("pPlayer"), bp::arg("iPointIndex"), bp::arg("pszReason")=bp::object(), bp::arg("iMaxReasonLength")=(int)(0) ) )    
        .def( 
            "PlayerMayCapturePoint"
            , (bool ( ::C_TeamplayRules::* )( ::C_BasePlayer *,int,char *,int ))(&::C_TeamplayRules::PlayerMayCapturePoint)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BasePlayer *,int,char *,int ))(&C_HL2MPRules_wrapper::default_PlayerMayCapturePoint)
            , ( bp::arg("pPlayer"), bp::arg("iPointIndex"), bp::arg("pszReason")=bp::object(), bp::arg("iMaxReasonLength")=(int)(0) ) )    
        .def( 
            "PointsMayBeCaptured"
            , (bool ( ::C_TeamplayRules::* )(  ))(&::C_TeamplayRules::PointsMayBeCaptured)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_PointsMayBeCaptured) )    
        .def( 
            "SetLastCapPointChanged"
            , (void ( ::C_TeamplayRules::* )( int ))(&::C_TeamplayRules::SetLastCapPointChanged)
            , (void ( C_HL2MPRules_wrapper::* )( int ))(&C_HL2MPRules_wrapper::default_SetLastCapPointChanged)
            , ( bp::arg("iIndex") ) )    
        .def( 
            "ShouldDrawHeadLabels"
            , (bool ( ::C_MultiplayRules::* )(  ))(&::C_MultiplayRules::ShouldDrawHeadLabels)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_ShouldDrawHeadLabels) )    
        .def( 
            "ShouldWarnOfAbandonOnQuit"
            , (bool ( ::C_GameRules::* )(  ))(&::C_GameRules::ShouldWarnOfAbandonOnQuit)
            , (bool ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_ShouldWarnOfAbandonOnQuit) )    
        .def( 
            "ShutdownGamerules"
            , (void ( ::C_GameRules::* )(  ))(&::C_GameRules::ShutdownGamerules)
            , (void ( C_HL2MPRules_wrapper::* )(  ))(&C_HL2MPRules_wrapper::default_ShutdownGamerules) )    
        .def( 
            "SwitchToNextBestWeapon"
            , (bool ( ::C_GameRules::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ))(&::C_GameRules::SwitchToNextBestWeapon)
            , (bool ( C_HL2MPRules_wrapper::* )( ::C_BaseCombatCharacter *,::C_BaseCombatWeapon * ))(&C_HL2MPRules_wrapper::default_SwitchToNextBestWeapon)
            , ( bp::arg("pPlayer"), bp::arg("pCurrentWeapon") ) )    
        .def( 
            "TeamMayCapturePoint"
            , (bool ( ::C_TeamplayRules::* )( int,int ))(&::C_TeamplayRules::TeamMayCapturePoint)
            , (bool ( C_HL2MPRules_wrapper::* )( int,int ))(&C_HL2MPRules_wrapper::default_TeamMayCapturePoint)
            , ( bp::arg("iTeam"), bp::arg("iPointIndex") ) )    
        .def( 
            "TranslateEffectForVisionFilter"
            , (char const * ( ::C_GameRules::* )( char const *,char const * ))(&::C_GameRules::TranslateEffectForVisionFilter)
            , (char const * ( C_HL2MPRules_wrapper::* )( char const *,char const * ))(&C_HL2MPRules_wrapper::default_TranslateEffectForVisionFilter)
            , ( bp::arg("pchEffectType"), bp::arg("pchEffectName") ) );

}

